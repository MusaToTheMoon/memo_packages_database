{
  "file_name": "io.reactivex.Observable",
  "source_type": "github",
  "url": "https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/core/Observable.java",
  "source_code_file_path": "java_source_code_files/io/reactivex/Observable.java",
  "is_success": false,
  "llm_model_name": "gemini-2.5-pro",
  "llm_analysis_timestamp": 1751898575,
  "run_name": "gemini-2.5-pro-pass-1",
  "llm_response_time_seconds": 610.769,
  "llm_analysis": "```json\n[\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> amb(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also calls `RxJavaPlugins.onAssembly`, which can introduce further side effects like logging if a plugin is configured to do so.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `sources` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It's a factory method that instantiates a new object, which is a side effect. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state. This makes the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> ambArray(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry. It may also call `empty()` or `wrap()`, which also interact with `RxJavaPlugins`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It calls `RxJavaPlugins.onAssembly`, which can introduce further side effects like logging if a plugin is configured to do so.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `sources` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates new `Observable` objects. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and dependent on external state. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static int bufferSize()\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"The method is a static utility that delegates to `Flowable.bufferSize()`. This, in turn, reads the global system property 'rx3.buffer-size', which constitutes a read access to global configuration state.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method does not have any observable side effects like I/O or state mutation. It only reads a system property.\",\n    \"hasSideEffects\": false,\n    \"reasonAboutNonDeterministicCalls\": \"The method's return value depends on the 'rx3.buffer-size' system property. Since this can be configured externally, the method's output is non-deterministic across different environments or program executions.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method has no arguments. Its output is determined by an external system property, not by its inputs or compile-time constants.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure because its return value depends on an external system property ('rx3.buffer-size'). This external dependency makes its output non-deterministic, and thus it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatest(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another `combineLatest` overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It's a factory method creating a new object. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatest(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatestArray(@NonNull ObservableSource<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another `combineLatestArray` overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It's a factory method creating a new object. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatestArray(@NonNull ObservableSource<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry. It also calls `empty()` which may interact with plugins.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates new `Observable` objects. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull BiFunction<? super T1, ? super T2, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4, @NonNull Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4, @NonNull ObservableSource<? extends T5> source5, @NonNull Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4, @NonNull ObservableSource<? extends T5> source5, @NonNull ObservableSource<? extends T6> source6, @NonNull Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4, @NonNull ObservableSource<? extends T5> source5, @NonNull ObservableSource<? extends T6> source6, @NonNull ObservableSource<? extends T7> source7, @NonNull Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull T8, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4, @NonNull ObservableSource<? extends T5> source5, @NonNull ObservableSource<? extends T6> source6, @NonNull ObservableSource<? extends T7> source7, @NonNull ObservableSource<? extends T8> source8, @NonNull Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull T8, @NonNull T9, @NonNull R> Observable<R> combineLatest(@NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4, @NonNull ObservableSource<? extends T5> source5, @NonNull ObservableSource<? extends T6> source6, @NonNull ObservableSource<? extends T7> source7, @NonNull ObservableSource<? extends T8> source8, @NonNull ObservableSource<? extends T9> source9, @NonNull Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to `combineLatestArray` which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatestArrayDelayError(@NonNull ObservableSource<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatestArrayDelayError(@NonNull ObservableSource<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry. It may also call `empty()` which interacts with plugins.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatestDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> combiner)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> combineLatestDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concat(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `fromIterable`, `bufferSize`, and `concatMapDelayError`, which in turn access global state by calling `RxJavaPlugins.onAssembly` and reading the 'rx3.buffer-size' system property.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `sources` argument, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concat(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another `concat` overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()`, which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `sources` argument, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concat(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concat(@NonNull ObservableSource<? extends T> source1, ObservableSource<? extends T> source2)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `concatArray`, which in turn accesses global state by calling `RxJavaPlugins.onAssembly` and potentially `bufferSize()`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it indirectly calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concat(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `concatArray`, which in turn accesses global state by calling `RxJavaPlugins.onAssembly` and potentially `bufferSize()`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it indirectly calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concat(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `concatArray`, which in turn accesses global state by calling `RxJavaPlugins.onAssembly` and potentially `bufferSize()`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it indirectly calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatArray(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry. It also calls `empty()` and `wrap()` which interact with plugins.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` which depends on a system property, and `RxJavaPlugins.onAssembly`, which depends on globally configured plugins.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatArrayDelayError(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It may call `empty()`, `wrap()`, and `concatDelayError()`, all of which ultimately interact with the global `RxJavaPlugins` registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatArrayEager(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatArrayEager(int maxConcurrency, int bufferSize, @NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `concatMapEagerDelayError`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatArrayEagerDelayError(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatArrayEagerDelayError(int maxConcurrency, int bufferSize, @NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `concatMapEagerDelayError`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `concatDelayError(fromIterable(sources))`. Both `fromIterable` and the subsequent `concatDelayError` call will interact with the global `RxJavaPlugins` registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another `concatDelayError` overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize, boolean tillTheEnd)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEager(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEager(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `concatMapEagerDelayError`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEager(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEager(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `wrap` and `concatMapEager`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEagerDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEagerDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `concatMapEagerDelayError`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEagerDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> concatEagerDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `wrap` and `concatMapEagerDelayError`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable`. Its behavior is dependent on the global `RxJavaPlugins` registry, which is a form of external state, making its output non-deterministic. Thus, it is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> create(@NonNull ObservableOnSubscribe<T> source)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `source` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> defer(@NonNull Supplier<? extends @NonNull ObservableSource<? extends T>> supplier)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input. The provided `supplier` can also be non-deterministic.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `supplier` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, and the passed `supplier` can produce different Observables, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> empty()\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It reads the static final field `ObservableEmpty.INSTANCE` and passes it to `RxJavaPlugins.onAssembly`, which accesses the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.internal.operators.observable.ObservableEmpty.INSTANCE\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method returns a shared `Observable` instance, potentially wrapped by plugins. This wrapping via `RxJavaPlugins.onAssembly` can introduce side effects like logging.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method has no arguments, but its result depends on the global `RxJavaPlugins` state.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. While it returns a singleton, it wraps this singleton via `RxJavaPlugins.onAssembly`. This dependency on the global, mutable plugin registry makes the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> error(@NonNull Supplier<? extends @NonNull Throwable> supplier)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that signals an error. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `supplier` can produce different `Throwable` instances, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `supplier` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior depends on the provided `supplier` and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> error(@NonNull Throwable throwable)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `error(Supplier)`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that signals an error. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `throwable` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior depends on the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromAction(@NonNull Action action)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that will execute the given `Action`. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `Action` can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `action` argument and the global state of `RxJavaPlugins`. The `Action` itself can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior depends on the provided `Action` and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromArray(@NonNull T... items)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry. It may also call `empty()` or `just()` which also interact with plugins.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `items` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromCallable(@NonNull Callable<? extends T> callable)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that will execute the given `Callable`. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `Callable` can have non-deterministic behavior (e.g., read from a file, access system time), and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `callable` argument and the global state of `RxJavaPlugins`. The `Callable` itself can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior depends on the provided `Callable` and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromCompletable(@NonNull CompletableSource completableSource)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from a `CompletableSource`, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `completableSource` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromFuture(@NonNull Future<? extends T> future)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from a `Future`. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook. The underlying `Future` represents an asynchronous computation which is a side effect.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because a `Future` represents an external computation that can be non-deterministic. The output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `future` argument (which represents external computation) and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object from a `Future`. The `Future`'s result is non-deterministic, and the method's behavior also depends on the global `RxJavaPlugins` registry. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromFuture(@NonNull Future<? extends T> future, long timeout, @NonNull TimeUnit unit)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from a `Future`. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook. The underlying `Future` represents an asynchronous computation which is a side effect.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because a `Future` represents an external computation that can be non-deterministic. The timeout adds a time-based non-determinism. The output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `future` argument (which represents external computation), timing, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object from a `Future` with a timeout. The `Future`'s result is non-deterministic, the timeout introduces time-dependency, and the method's behavior also depends on the global `RxJavaPlugins` registry. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromIterable(@NonNull Iterable<? extends T> source)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from an `Iterable`, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. The provided `Iterable` could also be non-deterministic if its iterator produces different sequences on subsequent calls.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `source` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the provided `Iterable` (which may be stateful) and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromMaybe(@NonNull MaybeSource<T> maybe)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from a `MaybeSource`, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `maybe` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromPublisher(@NonNull Publisher<? extends T> publisher)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from a `Publisher`, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. The `Publisher` itself is a source of asynchronous and potentially non-deterministic events.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `publisher` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the provided `Publisher` and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromRunnable(@NonNull Runnable run)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that will execute the given `Runnable`. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `Runnable` can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `run` argument and the global state of `RxJavaPlugins`. The `Runnable` itself can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior depends on the provided `Runnable` and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromSingle(@NonNull SingleSource<T> source)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object from a `SingleSource`, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `source` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> fromSupplier(@NonNull Supplier<? extends T> supplier)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that will execute the given `Supplier`. This is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `Supplier` can have non-deterministic behavior (e.g., read from a file, access system time), and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `supplier` argument and the global state of `RxJavaPlugins`. The `Supplier` itself can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior depends on the provided `Supplier` and the global `RxJavaPlugins` registry, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> generate(@NonNull Consumer<Emitter<T>> generator)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another `generate` overload which accesses global state by calling `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object. The provided `generator` is where side effects (like emitting values) will occur. The method itself has the side effect of object creation and potential plugin side effects.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `generator` can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `generator` argument and the global state of `RxJavaPlugins`. The `generator` can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided `generator` function and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull S> Observable<T> generate(@NonNull Supplier<S> initialState, @NonNull BiConsumer<S, Emitter<T>> generator)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another `generate` overload which accesses global state by calling `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object. The provided `generator` is where side effects (like emitting values) will occur. The method itself has the side effect of object creation and potential plugin side effects.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided `generator` and `initialState` supplier can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. The argument functions can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided `initialState` supplier, `generator` function and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull S> Observable<T> generate(@NonNull Supplier<S> initialState, @NonNull BiConsumer<S, Emitter<T>> generator, @NonNull Consumer<? super S> disposeState)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another `generate` overload which accesses global state by calling `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object. The provided `generator` is where side effects (like emitting values) will occur. The method itself has the side effect of object creation and potential plugin side effects.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided functions can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. The argument functions can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided functions (`initialState`, `generator`, `disposeState`) and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull S> Observable<T> generate(@NonNull Supplier<S> initialState, @NonNull BiFunction<S, Emitter<T>, S> generator)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another `generate` overload which accesses global state by calling `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object. The provided `generator` is where side effects (like emitting values) will occur. The method itself has the side effect of object creation and potential plugin side effects.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided functions can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. The argument functions can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided functions (`initialState`, `generator`) and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull S> Observable<T> generate(@NonNull Supplier<S> initialState, @NonNull BiFunction<S, Emitter<T>, S> generator, @NonNull Consumer<? super S> disposeState)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object. The provided `generator` is where side effects (like emitting values) will occur. The method itself has the side effect of object creation and potential plugin side effects.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided functions can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. The argument functions can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided functions (`initialState`, `generator`, `disposeState`) and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> interval(long initialDelay, long period, @NonNull TimeUnit unit)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload, which accesses global state via `Schedulers.computation()` and `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.schedulers.Schedulers.computation()\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits values based on time, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `Schedulers.computation()` and `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time, and the global state of `Schedulers` and `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `Schedulers` and `RxJavaPlugins` registries. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> interval(long initialDelay, long period, @NonNull TimeUnit unit, @NonNull Scheduler scheduler)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits values based on time using a scheduler, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time managed by the provided scheduler, and the global state of `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `RxJavaPlugins` registry. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> interval(long period, @NonNull TimeUnit unit)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload, which accesses global state via `Schedulers.computation()` and `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.schedulers.Schedulers.computation()\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits values based on time, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `Schedulers.computation()` and `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time, and the global state of `Schedulers` and `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `Schedulers` and `RxJavaPlugins` registries. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> interval(long period, @NonNull TimeUnit unit, @NonNull Scheduler scheduler)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload, which accesses global state via `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits values based on time using a scheduler, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time managed by the provided scheduler, and the global state of `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `RxJavaPlugins` registry. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, @NonNull TimeUnit unit)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload, which accesses global state via `Schedulers.computation()` and `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.schedulers.Schedulers.computation()\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits values based on time, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `Schedulers.computation()` and `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time, and the global state of `Schedulers` and `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `Schedulers` and `RxJavaPlugins` registries. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, @NonNull TimeUnit unit, @NonNull Scheduler scheduler)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits values based on time using a scheduler, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time managed by the provided scheduler, and the global state of `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `RxJavaPlugins` registry. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `item` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8, @NonNull T item9)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8, @NonNull T item9, @NonNull T item10)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to `fromArray`, which in turn calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeArray(int maxConcurrency, int bufferSize, @NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, int maxConcurrency)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> merge(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeArray(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, @NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, int maxConcurrency)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromIterable` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeDelayError(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> mergeArrayDelayError(@NonNull ObservableSource<? extends T>... sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly` through its delegation to `fromArray` and `flatMap`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> never()\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It reads the static final field `ObservableNever.INSTANCE` and passes it to `RxJavaPlugins.onAssembly`, which accesses the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.internal.operators.observable.ObservableNever.INSTANCE\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method returns a shared `Observable` instance, potentially wrapped by plugins. This wrapping via `RxJavaPlugins.onAssembly` can introduce side effects like logging.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method has no arguments, but its result depends on the global `RxJavaPlugins` state.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. While it returns a singleton, it wraps this singleton via `RxJavaPlugins.onAssembly`. This dependency on the global, mutable plugin registry makes the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Integer> range(int start, int count)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry. It may also call `empty()` or `just()` which also interact with plugins.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> rangeLong(long start, long count)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry. It may also call `empty()` or `just()` which also interact with plugins.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Single<Boolean> sequenceEqual(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Single` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Single`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Single<Boolean> sequenceEqual(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull BiPredicate<? super T, ? super T> isEqual)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Single` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Single`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Single<Boolean> sequenceEqual(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull BiPredicate<? super T, ? super T> isEqual, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Single` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Single` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Single` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Single` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Single<Boolean> sequenceEqual(@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Single` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Single` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Single` object. Its behavior is also dependent on the global `RxJavaPlugins` registry, which is a form of external state, making the method's output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> switchOnNext(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> switchOnNext(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> switchOnNextDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'. It then delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the 'rx3.buffer-size' system property, and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for a new `Observable`. Its result depends on external state (system properties via `bufferSize()` and the `RxJavaPlugins` registry), making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> switchOnNextDelayError(@NonNull ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> timer(long delay, @NonNull TimeUnit unit)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload, which accesses global state via `Schedulers.computation()` and `RxJavaPlugins.onAssembly`.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.schedulers.Schedulers.computation()\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits a value after a delay, which is a time-based side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `Schedulers.computation()` and `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time, and the global state of `Schedulers` and `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `Schedulers` and `RxJavaPlugins` registries. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static Observable<Long> timer(long delay, @NonNull TimeUnit unit, @NonNull Scheduler scheduler)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object that emits a value after a delay using a scheduler, which is a time-based side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because it relies on a `Scheduler` for timing, which is inherently time-based. It also depends on the global `RxJavaPlugins` state.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its arguments, the passage of time managed by the provided scheduler, and the global state of `RxJavaPlugins`.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It creates an `Observable` that is time-dependent. Its behavior also depends on the global `RxJavaPlugins` registry. It is not suitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> unsafeCreate(@NonNull ObservableSource<T> onSubscribe)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `onSubscribe` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that creates a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull D> Observable<T> using(@NonNull Supplier<? extends D> resourceSupplier, @NonNull Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, @NonNull Consumer<? super D> resourceCleanup)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It delegates to another overload which calls `RxJavaPlugins.onAssembly`, accessing the global plugin registry.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook and the provided resource management functions.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided supplier/function arguments can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its functional arguments and the global state of `RxJavaPlugins`. The functions can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided functions (`resourceSupplier`, `sourceSupplier`, `resourceCleanup`) and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull D> Observable<T> using(@NonNull Supplier<? extends D> resourceSupplier, @NonNull Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, @NonNull Consumer<? super D> resourceCleanup, boolean eager)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the created `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook and the provided resource management functions.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because the provided supplier/function arguments can have non-deterministic behavior, and the output also depends on the global state of `RxJavaPlugins`.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its functional arguments and the global state of `RxJavaPlugins`. The functions can depend on anything.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method for creating a new `Observable`. Its behavior depends on the provided functions (`resourceSupplier`, `sourceSupplier`, `resourceCleanup`) and the global `RxJavaPlugins` registry, making it non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T> Observable<T> wrap(@NonNull ObservableSource<T> source)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`, which reads from the global plugin registry to potentially wrap or modify the `Observable` instance.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to wrap an `ObservableSource` into an `Observable`, which may involve creating a new object. It has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"This method is non-deterministic because its output depends on the global state of `RxJavaPlugins`. Different plugins can be configured at runtime, leading to different `Observable` instances being returned for the same input.\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly\": \"The method's output depends on its `source` argument and the global state of `RxJavaPlugins`. Therefore, it does not depend purely on its arguments.\",\n    \"dependsOnArgumentsOnly\": false,\n    \"purityInfo\": {\n      \"reasonAboutIsPureLLM\": \"The method is not pure. It is a factory method that may create a new `Observable` object. Its behavior is dependent on the global `RxJavaPlugins` registry, making its output non-deterministic and unsuitable for memoization.\",\n      \"isPureLLM\": false\n    }\n  },\n  {\n    \"methodSignature\": \"public static <@NonNull T, @NonNull R> Observable<R> zip(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> zipper)\",\n    \"className\": \"io.reactivex.rxjava3.core.Observable\",\n    \"reasonAboutStateAccesses\": \"This static factory method does not access any instance state. It accesses global state by calling `RxJavaPlugins.onAssembly`. It also calls `bufferSize()`, which reads the global system property 'rx3.buffer-size'.\",\n    \"stateAccesses\": [\n      {\n        \"name\": \"rx3.buffer-size\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"PRIMITIVE\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      },\n      {\n        \"name\": \"io.reactivex.rxjava3.plugins.RxJavaPlugins.onObservableAssembly\",\n        \"scope\": \"GLOBAL\",\n        \"valueType\": \"OBJECT\",\n        \"accessType\": \"READ\",\n        \"idempotent\": null\n      }\n    ],\n    \"reasonAboutSideEffects\": \"The method's primary purpose is to create a new `Observable` object, which is a side effect. It also has potential side effects through the `RxJavaPlugins.onAssembly` hook.\",\n    \"hasSideEffects\": true,\n    \"reasonAboutNonDeterministicCalls\": \"The method is non-deterministic because it calls `bufferSize()` and `RxJavaPlugins.onAssembly`, which depend on external configuration (system properties and plugins).\",\n    \"hasNonDeterministicCalls\": true,\n    \"reasonAboutDependsOnArgumentsOnly"
}